\begin{note}
  This section provides a \textbf{proposal} on how the ledger rules can be used
  to build the blockchain ones. It was mainly developed to help me
  understanding what the blockchain layer requires from the ledger layer, and
  the aspects that need to be modeled in the former. In addition, my
  expectation with this section is that we can discuss which tasks should be
  completed in order to finish a first draft of the blockchain and ledger
  specifications, so that we can move forward with the generators. This section
  was not intended as a replacement of the blockchain spec, which can be found
  in a different document.-- Damian Nadales
\end{note}

\subsection{Chain extension}
\label{sec:chain-extension}

The chain extension rule is given in Figure~\ref{fig:rules:chain-extension},
and the definitions used in this rule are presented in
Figure~\ref{fig:defs:chain-extension}. Rule~\ref{eq:rule:chain-extension}
relies on transitions $\trans{bdeleg}{}$, which specify the delegation
behavior, and $\trans{butxo}{}$ which models the evolution of unspent outputs
after applying the transitions in a block. Rules for delegation and unspent
outputs in the context of a block are given in
Sections~\ref{sec:block-delegation} and \ref{sec:block-utxo} respectively.

\begin{figure}
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{b} & \Block & \text{block}\\
      \var{s} & \SlotId & \text{slot id}\\
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    \fun{bwit} & \Block \to (\VKey \times \Sig) & \text{block witness}\\
      \fun{bepoch} & \Block \to \Epoch & \text{block epoch}\\
      \fun{bslot} & \Block \to \SlotId & \text{block slot id}\\
    \fun{s_0} & \SlotId  & \text{slot zero (smallest slot id)}\\
    \end{array}
  \end{equation*}
  \caption{Blockchain extension definitions}
  \label{fig:defs:chain-extension}
\end{figure}

\begin{figure}
  \emph{Chain extension environment}
  \begin{equation*}
    \CEEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{\Gkeys} & \powerset{\VKeyGen} & \text{genesis keys}\\
        \var{K} & \mathbb{N} & \text{number of nodes}\\
        \var{t} & \mathbb{Q} & \text{byzantine nodes ratio}\\
        \var{d} & \Epoch & \text{delegation liveness parameter}\\
      \end{array}
    \right)
  \end{equation*}
  \emph{Chain extension states}
  \begin{equation*}
    \CEState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \beta & \seqof{\Block} & \text{blockchain}\\
        \var{utxo} & \UTxO & \text{blockchain unspent outputs}\\
        \var{dmap} & \VKeyGen \mapsto \VKey & \text{blockchain delegation map}\\
        \var{signers} & \seqof{\VKeyGen} & \text{last $K$ blockchain signers}\\
        \var{sid_c} & \SlotId & \text{current slot}\\
        \var{pdlgs} & \SlotId \mapsto \seqof{\DCert} & \text{pending delegations}\\
        \var{ekeys} & \Epoch \mapsto \powerset{\VKeyGen} & \text{keys delegated per epoch}
      \end{array}
    \right)
  \end{equation*}
  \emph{Chain extension transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{chain}{\_} \_ \in
      \powerset (\CEEnv \times \CEState \times \Block \times \CEState)
  \end{equation*}
  \caption{Chain extension transition-system types}
  \label{fig:ts-types:chain-extension}
\end{figure}

\begin{figure}
  \begin{equation}
    \label{eq:rule:chain-base}
    \inference[Chain-base]
    {}
    {\left(
        \begin{array}{l}
          \var{utxo}\\
          \var{\{ (\var{vk}, \var{vk}) \mid \var{vk} \in \Gkeys\}}\\
          \emptyset\\
          \var{s_0}\\
          \emptyset\\
          \emptyset
        \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}
    \label{eq:rule:chain-extension}
    \inference[Chain-ext]
    {\bslot{b} = \var{sid_n} & 
      \var{sid_c} < \var{sid_n} &
      \var{epo_c} = \fun{bepoch}~b \\
      {\begin{array}{l}
         \var{epo_c}\\
         \var{sid_n}\\
         d
       \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{dmap}\\
            \var{pdlgs}\\
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{bdeleg}{b}
      {
        \left(
          \begin{array}{r}
            \var{dmap'}\\
            \var{pdlgs'}\\
            \var{ekeys'}
          \end{array}
        \right)
      }
      \\
      {\begin{array}{l}
         K\\
         t\\
         \var{sid_n}\\
         \var{dmap'}
      \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{signers}
          \end{array}
        \right)
      }
      \trans{BSIGN}{b}
      {
        \left(
          \begin{array}{l}
            \var{signers'}
          \end{array}
        \right)
      }      
      &
      {
        \left(
          \begin{array}{l}
            \var{utxo}\\
          \end{array}
        \right)
      }
      \trans{butxo}{b}
      {
        \left(
          \begin{array}{r}
            \var{utxo'}\\
          \end{array}
        \right)
      }
    }
    {
      {\begin{array}{l}
         \Gkeys\\
         K\\
         t\\
         d
      \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{utxo}\\
            \var{dmap}\\
            \var{signers}\\
            \var{sid_c}\\
            \var{pdlgs}\\
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{chain}{b}
      {
        \left(
          \begin{array}{l}
            \var{utxo}\\
            \var{dmap'}\\
            \var{signers'}\\
            \var{sid_n}\\
            \var{pdlgs'}\\
            \var{ekeys'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Chain extension rules}
  \label{fig:rules:chain-extension}
\end{figure}


\begin{figure}
  \begin{equation}
    \label{eq:rule:block-signing}
    \inference[Chain-ext]
    {\var{vk_g} \mapsto vk_d \in \var{dmap} & \bwit{b} = (\var{vk_d}, \sigma)\\
      \size{\{vk_g\} \restrictdom signers} \leq K * t &
      \verify{vk_d}{\serialised{\bbody{b}}}{\sigma} \\
      \var{signers'} =
         \{ \var{sid} \mapsto \var{vk}
          \mid  \var{sid} \mapsto \var{vk} \in \var{signers} \cup \{\var{sid_c} \mapsto vk_g\}
          , \var{sid_c} - K \leq \var{sid} \}
    }
    {
      {\begin{array}{l}
         K\\
         t\\
         \var{sid_c}\\
         \var{dmap}
      \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{signers}
          \end{array}
        \right)
      }
      \trans{BSIGN}{b}
      {
        \left(
          \begin{array}{l}
            \var{signers'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Block signing rules}
  \label{fig:rules:block-signing}
\end{figure}

\subsection{Block delegation}
\label{sec:block-delegation}

The rule for delegation of certificates in a block is shown in
Figure~\ref{fig:rules:block-delegation}, and the new definitions used in this
rule are presented in Figure~\ref{fig:defs:block-delegation}.
Rule~\ref{eq:rule:block-delegation} relies on an inference rule that models the
state changes after applying a sequence of delegation certificates. Such rule
is shown in Figure~\ref{fig:rules:delegation-sequence}.

\begin{figure}
  \emph{Abstract functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{bdlgs} & \Block \mapsto \seqof{\DCert} & \text{delegation certificates in the block}\\
    \end{array}
  \end{equation*}
  \caption{Block delegation definitions}
  \label{fig:defs:block-delegation}
\end{figure}

\begin{figure}
  \emph{Block delegation environments}
  \begin{equation*}
    \BDEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{epo_c} & \Epoch & \text{current epoch}\\
        \var{sid_c} & \SlotId & \text{current slot id}\\
        \var{d} & \Epoch & \text{delegation liveness parameter}\\
      \end{array}
    \right)
  \end{equation*}
  \emph{Block delegation states}
  \begin{equation*}
    \BDState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{dmap} & \VKeyGen \mapsto \VKey & \text{blockchain delegation map}\\
        \var{pdlgs} & \SlotId \mapsto \seqof{\DCert} & \text{pending delegations}\\
        \var{ekeys} & \Epoch \mapsto \powerset{\VKeyGen} & \text{keys delegated per epoch}
      \end{array}
    \right)
  \end{equation*}
  \emph{Block delegation transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{chain}{\_} \_ \in
      \powerset (\BDEnv \times \BDState \times \Block \times \CEState)
  \end{equation*}
  \caption{Block delegation transition-system types}
  \label{fig:ts-types:block-delegation}
\end{figure}

\begin{figure}
  \begin{equation}
    \label{eq:rule:block-delegation}
    \inference[Block-dlg]
    {
      {\begin{array}{r@{~=~}l}
         \var{pdlgs'} & \var{pdlgs} \unionoverride \{(\bslot{b} + d) \mapsto \bdlgs{b} \}\\
         \var{spast} & \{ \var{sid} \mid \var{sid} \in \var \dom ~ \var{pdlgs'}
                       ,~ \var{sid} \leq \var{sid_c}\}\\
         \var{active} &  \fun{concat}~ [ \var{dlgs} \mid \var{sid} \mapsto \var{dlgs} \in \var{pdlgs}
                                          ,~ \var{sid} \leq \var{sid_c}]
      \end{array}} & \\
      \var{epo_c} \vdash
      {
        \left(
          \begin{array}{l}
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{epochs}{\bdlgs{b}}
      {
        \left(
          \begin{array}{r}
            \var{ekeys'}
          \end{array}
        \right)
      } & 
      \var{epo_c} \vdash
      {
        \left(
          \begin{array}{l}
            \var{dmap}
          \end{array}
        \right)
      }
      \trans{delegs}{\var{active}}
      {
        \left(
          \begin{array}{r}
            \var{dmap'}
          \end{array}
        \right)
      }     
    }
    {
      \begin{array}{l}
        \var{epo_c}\\
        \var{sid_c}\\
        d
      \end{array}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{dmap}\\
            \var{pdlgs}\\
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{bdeleg}{b}
      {
        \left(
          \begin{array}{r}
            \var{dmap'}\\
            \var{\var{spast} \subtractdom pdlgs'}\\
            \var{ekeys'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Block delegation rules}
  \label{fig:rules:block-delegation}
\end{figure}

\begin{figure}
  \begin{equation}
    \inference[Seq-delg-base]
    {}
    { \left(
        \begin{array}{r}
          \var{dmap}
        \end{array}
      \right)
        \trans{delegs}{\epsilon}
      \left(
        \begin{array}{r}
          \var{dmap}
        \end{array}
      \right)
    }
    \label{eq:rule:sequence-delegation-base}
  \end{equation}

  \begin{equation}
    \inference[Seq-delg-ind]
    { {\left(
        \begin{array}{r}
          \var{dmap}
        \end{array}
      \right)}
      \trans{delegs}{\Gamma}
      {\left(
        \begin{array}{r}
          \var{dmap'}
        \end{array}
      \right)}
    &
    {\left(
        \begin{array}{r}
          \var{dmap'}
        \end{array}
      \right)}
      \trans{delegw}{c}
      {\left(
        \begin{array}{r}
          \var{dmap''}
        \end{array}
      \right)}
    }
    { \left(
        \begin{array}{r}
          \var{dmap}
        \end{array}
      \right)
      \trans{delegs}{\Gamma; c}
      \left(
        \begin{array}{r}
          \var{dmap''}
        \end{array}
      \right)
    }
    \label{eq:rule:sequence-delegation-inductive}
  \end{equation}
  \caption{Delegation sequence rules}
  \label{fig:rules:delegation-sequence}
\end{figure}

\begin{figure}
  \begin{equation}
    \inference[Seq-delg-base]
    {}
    { \var{epo_c} \vdash \left(
        \begin{array}{r}
          \var{ekeys}
        \end{array}
      \right)
        \trans{depochs}{\epsilon}
      \left(
        \begin{array}{r}
          \var{\emptyset}
        \end{array}
      \right)
    }
    \label{eq:rule:depoch-sequence-base}
  \end{equation}

  \begin{equation}
    \inference[Seq-delg-ind]
    { \var{epo_c} \vdash
      {\left(
        \begin{array}{r}
          \var{ekeys}
        \end{array}
      \right)}
      \trans{depochs}{\Gamma}
      {\left(
        \begin{array}{r}
          \var{ekeys'}
        \end{array}
      \right)}
    &
    \var{epo_c} \vdash
    {\left(
        \begin{array}{r}
          \var{ekeys'}
        \end{array}
      \right)}
      \trans{depoch}{c}
      {\left(
        \begin{array}{r}
          \var{ekeys''}
        \end{array}
      \right)}
    }
    { \var{epo_c} \vdash \left(
        \begin{array}{r}
          \var{ekeys}
        \end{array}
      \right)
      \trans{depochs}{\Gamma; c}
      \left(
        \begin{array}{r}
          \var{ekeys''}
        \end{array}
      \right)
    }
    \label{eq:rule:depoch-sequence-inductive}
  \end{equation}
  \caption{Delegation epoch sequence rules}
  \label{fig:rules:epoch-sequence}
\end{figure}

\subsection{Block UTxO}
\label{sec:block-utxo}

\begin{todo}
  Block-UTxO rules will have the same structure as the rules presented in
  Section~\ref{sec:block-delegation}.
\end{todo}
