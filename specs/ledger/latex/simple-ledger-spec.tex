\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\hypersetup{
  pdftitle={A Simplified Formal Specification of a UTxO Ledger},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}
% For notes containing warnings, questions, etc.
\usepackage[tikz]{bclogo}
\newenvironment{question}
  {\begin{bclogo}[logo=\bcquestion, couleur=orange!10, arrondi=0.2]{ QUESTION}}
  {\end{bclogo}}
\newenvironment{todo}
  {\begin{bclogo}[logo=\bcoutil, couleur=red!5, couleurBarre=red, arrondi=0.2]{ TODO}}
  {\end{bclogo}}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
%% TODO: we should package this
%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\signed}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}
\newcommand{\where}{~ ~ \mathbf{where}~ ~ }

%%
%% Types
%%
\newcommand{\Tx}{\type{Tx}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Value}{\type{Value}}
\newcommand{\Coin}{\type{Coin}}
% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}
\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
% Adding delegation
\newcommand{\DCert}{\type{DCert}}
\newcommand{\DState}{\type{DState}}
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\VKeyGen}{\type{VKeyGen}}
%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\balance}[1]{\fun{balance}~ \var{#1}}
%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\wits}[1]{\fun{wits}~ \var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\addr}[2]{\fun{addr}~ \var{#1}~ \var{#2}}
\newcommand{\hash}[1]{\fun{hash}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}

\begin{document}

\title{A Simplified Formal Specification of a UTxO Ledger}

\author{}

\date{September 24, 2018}

\maketitle

\begin{abstract}
This documents defines the rules for extending a ledger with transactions. It
is intended to serve as the specification for random generators of transactions
which adhere to the rules presented here.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

This specification models the \textit{conditions} required for the extension of
a ledger, which is represented here as a list of transactions. The following
aspects are part of such conditions:

\begin{description}
\item[Preservation of value] relationship between the total value of input and outputs
  in a new transaction, and the unspent outputs.
\item[Witnesses] cryptographic entities needed to validate the spending
  of a transaction input.
\item[Delegation] delegation certificates, which delegate the block-signing
  rights from a genesis key to another public key.
\end{description}

The following aspects will not be modeled (since they are not part of the legacy-free
implementation):
\begin{description}
\item[Stake] staking rights associated to a addresses.
\item[Update validation] voting mechanism which captures the identification of
  the voters, and the participants that can post update proposals.
\end{description}

\section{Notation}\label{sec:notation}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequences] Given a set $\type{X}$, $\seqof{\type{X}}$ is the set of
  sequences having elements taken from $\type{X}$. The empty sequence is
  denoted by $\epsilon$, and given a sequence $\Lambda$, $\Lambda; \type{x}$ is
  the sequence that results from appending $\type{x} \in \type{X}$ to
  $\Lambda$.
\end{description}

\section{State transitions for UTxO}
\label{sec:state-trans-utxo-1}

The transition rules for unspent outputs are presented in
Figure~\ref{fig:state-trans-utxo}. The states of the UTxO transition system,
along with their types are defined in Figure~\ref{fig:state-trans-utxo-defs}.
Functions on these types are defined in Figure~\ref{fig:utxo-auxiliary-ops}.

\begin{figure}
  \begin{equation}\label{eq:utxo-inductive}
    \inference[UTxO-inductive]
    { \txins{tx} \subseteq \var{utxo}
      & \balance{(\txouts{tx})} \leq \balance{(\txins{tx} \restrictdom \var{utxo})}
    }
    {\var{utxo} \trans{utxo}{tx}
      (\txins{tx} \subtractdom \var{utxo}) \cup \txouts{tx}
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:state-trans-utxo}
\end{figure}

Rule~\ref{eq:utxo-inductive} specifies under which conditions a transaction can
be applied to a set of unspent outputs, and how the set of unspent output
changes with a transaction:
\begin{itemize}
\item The set spent inputs in the transaction, must be in the set of unspent
  outputs.
\item The balance of the unspent outputs in a transaction (i.e. the total
  amount paid in a transaction) must be equal less than the amount of spent
  inputs.
\item If the above conditions hold, then the new state will not have the inputs
  spent in transaction $\var{tx}$ and it will have the new outputs in
  $\var{tx}$.
\end{itemize}

\begin{figure*}
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{tx} & \Tx & \text{transaction}\\
    \end{array}
  \end{equation*}
  \emph{Primitive types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{txid} & \TxId & \text{transaction id}\\
      %
      ix & \Ix & \text{index}\\
      %
      \var{addr} & \Addr & \text{address}\\
      %
      c & \Coin & \text{currency value}
    \end{array}
  \end{equation*}
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
      \var{txin}
      & \TxIn
      & (\var{txid}, \var{ix})
      & \TxId \times \Ix
      & \text{transaction input}
      \\
      \var{txout}
      & \type{TxOut}
      & (\var{addr}, c)
      & \Addr \times \Coin
      & \text{transaction output}
      \\
      \var{utxo}
      & \UTxO
      & \var{txin} \mapsto \var{txout}
      & \TxIn \mapsto \TxOut
      & \text{unspent tx outputs}
    \end{array}
  \end{equation*}
  \emph{UTxO States}
  %
  \begin{equation*}
    \var{utxo} \in \UTxO
  \end{equation*}
  %
  \emph{UTxO Transitions}
  \begin{equation*}
    \var{\_} \trans{utxo}{\_} \var{\_}
    \subseteq \powerset (\UTxO \times \Tx \times \UTxO)
  \end{equation*}
  %
  \emph{Abstract Functions}
  \begin{align*}
    & \txid{} \in \Tx \mapsto \TxId & \text{compute transaction id}\\
    %
    & \fun{txbody} \in \Tx \mapsto \powerset{\TxIn} \times (\Ix \mapsto \TxOut)
    & \text{transaction body}
  \end{align*}
  \caption{Definitions associated to the UTxO transition system}
  \label{fig:state-trans-utxo-defs}
\end{figure*}

\begin{figure}
  \begin{align*}
    & \fun{txins} \in \Tx \to \powerset{\TxIn}
    & \text{transaction inputs} \\
    & \txins{tx} = \var{inputs} \where \txbody{tx} = (\var{inputs}, ~\wcard)
    \nextdef
    & \fun{txouts} \in \Tx \to \UTxO
    & \text{transaction outputs as UTxO} \\
    & \fun{txouts} ~ \var{tx} =
      \left\{ (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
      \middle| \begin{array}{l@{~}c@{~}l}
                 (\_, \var{outputs}) & = & \txbody{tx} \\
                 \var{ix} \mapsto \var{txout} & \in & \var{outputs}
               \end{array}
      \right\}
    \nextdef
    & \fun{balance} \in \UTxO \to \Coin
    & \text{UTxO balance} \\
    & \fun{balance} ~ utxo = \sum_{(~\wcard ~ \mapsto (\wcard, ~c)) \in \var{utxo}} c
  \end{align*}

  \begin{align*}
    \var{ins} \restrictdom \var{utxo}
    & = \{ i \mapsto o \mid i \mapsto o \in \var{utxo}, ~ i \in \var{ins} \}
    & \text{domain restriction}
    \\
    \var{ins} \subtractdom \var{utxo}
    & = \{ i \mapsto o \mid i \mapsto o \in \var{utxo}, ~ i \notin \var{ins} \}
    & \text{domain exclusion}
    \\
    \var{utxo} \restrictrange \var{outs}
    & = \{ i \mapsto o \mid i \mapsto o \in \var{utxo}, ~ o \in \var{outs} \}
    & \text{range restriction}
  \end{align*}
  \caption{UTxO operations}
  \label{fig:utxo-auxiliary-ops}
\end{figure}

\subsection{Properties}
\label{sec:utxo-properties}

\begin{todo}
  Can we prove properties of the transition system of this section? For
  instance we might like to formalize ``double spending'' and prove that these
  rules prevent it. Do we want it?
\end{todo}

\subsection{Witnesses}
\label{sec:witnesses}

The rules for witnesses are presented in Figure~\ref{fig:rules-utxo-witnesses}.
The definitions used in Rule~\ref{eq:utxo-witness-inductive} are given in
Figure~\ref{fig:state-trans-utxo-witnesses-defs}. Note that
Rule~\ref{eq:utxo-witness-inductive} uses the transition relation defined in
Figure~\ref{fig:state-trans-utxo}. The main reason for doing this is to define
the rules incrementally, modeling different aspects in isolation to keep the
rules as simple as possible. Also note that the $\trans{utxo}{}$ relation could
have been defined in terms of $\trans{utxow}{}$ (thus composing the rules in a
different order). The choice here is arbitrary.

\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive}
    \inference[UTxO-wit]
    { \var{utxo} \trans{utxo}{tx} \var{utxo'}\\ ~ \\
      & \forall i \in \txins{tx} \cdot
           \exists (\var{vk}, \sigma) \in \wits{\var{tx}} \cdot
              \verify{vk}{\serialised{\txbody{tx}}}{\sigma}  \wedge \addr{i}{utxo} = \hash{vk}
    }
    {\var{utxo} \trans{utxow}{tx} \var{utxo'}}
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules-utxo-witnesses}
\end{figure}

\begin{figure}
  \emph{Abstract types}
  %
  \begin{align*}
    & \VKey & \text{verification key}\\
    & \Sig  & \text{signature}\\
    & \Data  & \text{data}\\
  \end{align*}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{wits} & \Tx \mapsto \powerset{(\VKey \times \Sig)}
      & \text{witnesses of a transaction}\\
      %
      \fun{verify} & \VKey \times \Data \times \Sig
      & \text{verification relation}\\
      %
      \hash{} & \VKey \mapsto \Addr
      & \text{hash function} \\
    \end{array}
  \end{equation*}
  \emph{Functions}
  %
  \begin{align*}
    & \addr{}{} \in \TxIn \mapsto \UTxO \mapsto \Addr\\
    & \addr{i}{utxo} = \var{hk} \where (hk, \wcard) = \var{utxo}~i
  \end{align*}
  \caption{Definitions associated to the UTxO transition system with witnesses}
  \label{fig:state-trans-utxo-witnesses-defs}
\end{figure}

\section{Delegation}
\label{sec:delegation}

An agent owning a key that can sign new blocks can delegate its signing rights
to another key by means of \textit{delegation certificates}. These certificates
are included in the ledger, and therefore also included in the body of the
blocks in the blockchain.

In the blockchain protocol only a certain number of keys can sign blocks, and
the verifying part of these keys\footnote{Also known as public keys.} are
maintained in the genesis block. One important restriction on delegation is
that only the keys in the genesis block can delegate to other keys. However, at
the ledger level we do not know which are these keys, and thus this is a
restriction to be enforced at the blockchain level. In this formalization we
only care about establishing, whether $\var{vk}_s$ delegated its rights to
$\var{vk}_d$. To keep track of this, we use a map from keys to keys.

The rule for delegation is presented in
Figure~\ref{fig:state-trans-delegation}. It states that if $\var{c}$ is a valid
delegation certificate from key $\var{vk}_s$ to key $\var{vk}_d$, then the
delegation map $d$ is updated to contain the key mapping
$\var{vk}_s \mapsto \var{vk}_d$. The symbol $\unionoverride$ denotes
union-override, and is defined in Figure~\ref{fig:delegation-defs}. Another
condition that is checked in the delegation rule is that each genesis key can
issue at most one delegation certificate per epoch. To check this, the states
of the transitions system maintain a map from epochs to set of keys that were
delegated on a given epoch. Finally, the delegation epoch cannot be older than
the current epoch. This is what allow us to clean up the maps of keys delegated
per epoch. The $\vdash$ symbol denotes an \textit{environment} that remains
constant in the rules. This environment (the current epoch in this case) would
be set by the (chain) rules that use Rule~\ref{eq:delegation}.

\begin{figure}
  \begin{equation}\label{eq:delegation}
    \inference[Delegation]
    {\dwho{c} = (vk_s, vk_d) & \depoch{c} = e_c & \var{vk_s} \notin \var{ekeys}~e_c & \var{cepoch} \leq e_c\\
      \var{ekeys'} = \{ (e, \var{vks})  \mid (e, \var{vks}) \in \var{ekeys},~  \var{cepoch} \leq e \}
    }
    {
      \var{cepoch} \vdash
      \left(
      \begin{array}{r}
        \var{dmap}\\
        \var{ekeys}
      \end{array}
      \right)
      \trans{deleg}{c}
      \left(
      \begin{array}{lcl}
        \var{dmap} & \unionoverride & \{\var{vk_s} \mapsto \var{vk_d}\}\\
        \var{ekeys'} & \unionoverride & \{e_c \mapsto (\var{ekeys'}~e_c \cup \{\var{vk_s}\})\}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation inference rules}
  \label{fig:state-trans-delegation}
\end{figure}

\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      c & \DCert  & \text{delegation certificate}\\
      vk_g & \VKeyGen & \text{genesis verification key}
    \end{array}
  \end{equation*}
  \emph{Constraints}
  \begin{align*}
    \VKeyGen \subseteq \VKey
  \end{align*}
  \emph{Delegation states}
  \begin{equation*}
    \DState =
    \left(\begin{array}{r@{~\in~}lr}
      \var{dmap} & \VKeyGen \mapsto \VKey & \text{delegation map}\\
      \var{ekeys} & \Epoch \mapsto \powerset{\VKeyGen} & \text{keys delegated per epoch}
    \end{array}\right)
  \end{equation*}
  \emph{Delegation transition}
  \begin{equation*}
    \_ \vdash \_ \trans{deleg}{\_} \_ \in
      \powerset (\Epoch \times \DState \times \DCert \times \DState)
  \end{equation*}
  \emph{Abstract functions}
  \begin{align*}
    & \fun{dwho} \in \DCert \mapsto (\VKeyGen \times \VKey) & \text{who delegates to who in the certificate}\\
    & \fun{depoch} \in \DCert \mapsto \Epoch & \text{certificate epoch}
  \end{align*}
  \emph{Functions}
  \begin{equation*}
    \begin{array}{rcl}
      \unionoverride & \in & (A \mapsto B) \mapsto (A \mapsto B) \mapsto (A \mapsto B)\\
      (d_0 \unionoverride d_1)~k & = &
      \begin{cases}
        d_1~k & k \in \dom d_1\\
        d_0~k & \text{otherwise}\\
      \end{cases}
    \end{array}
  \end{equation*}
  \caption{Delegation definitions}
  \label{fig:delegation-defs}
\end{figure}

\subsection{Witnesses}
\label{sec:delegation-witnesses}

The rule for certificate witnesses is given in
Figure~\ref{fig:deleg-witnesses}. The new definitions introduced in this rule
are given in Figure~\ref{fig:delegation-witnesses-defs}.

\begin{figure}
  \begin{equation}
    \label{eq:deleg-witnesses}
    \inference[deleg-wit]
    { \dwit{c} = (\var{vk_s}, \sigma)
      & \var{cepoch} \vdash
      {\left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)}
      \trans{deleg}{c}
      {\left(
      \begin{array}{l}
          \var{dmap}\\
          \var{ekeys}
      \end{array}
      \right)}
      \\ ~ \\
      \verify{vk_s}{\serialised{\dbody{c}}}{\sigma}
    }
    {\var{cepoch} \vdash
      {\left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)}
      \trans{delegw}{c}
      {\left(
      \begin{array}{l}
          \var{dmap}\\
          \var{ekeys}
      \end{array}
      \right)}}
  \end{equation}
  \caption{Delegation witnesses inference rules}
  \label{fig:deleg-witnesses}
\end{figure}

\begin{figure}
  \emph{Primitive types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{epoch} & \Epoch & \text{epoch}
    \end{array}
  \end{equation*}
    \emph{Abstract functions}
  \begin{align*}
      & \fun{dbody} \in \DCert \mapsto \VKey \times \Epoch & \text{body of the delegation certificate}\\
      & \fun{dwit} \in \DCert \mapsto (\VKeyGen \times \Sig) & \text{witness for the delegation certificate}
  \end{align*}
  \caption{Delegation witnesses definitions}
  \label{fig:delegation-witnesses-defs}
\end{figure}

\end{document}
