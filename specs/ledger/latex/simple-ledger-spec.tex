\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{microtype}
\usepackage{mathpazo} % nice fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{slashed}
\usepackage[colon]{natbib}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage{xcolor}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\hypersetup{
  pdftitle={A Simplified Formal Specification of a UTxO Ledger},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}
% For notes containing warnings, questions, etc.
\usepackage[tikz]{bclogo}
\newenvironment{question}
  {\begin{bclogo}[logo=\bcquestion, couleur=orange!10, arrondi=0.2]{ QUESTION}}
  {\end{bclogo}}
\newenvironment{todo}
  {\begin{bclogo}[logo=\bcoutil, couleur=red!5, couleurBarre=red, arrondi=0.2]{ TODO}}
    {\end{bclogo}}
\newenvironment{note}
  {\begin{bclogo}[logo=\bcattention, couleur=orange!10, arrondi=0.2]{ NOTE}}
  {\end{bclogo}}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
%% TODO: we should package this
%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\signed}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}
\newcommand{\where}{~ ~ \mathbf{where}~ ~ }

%%
%% Types
%%
\newcommand{\Tx}{\type{Tx}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Value}{\type{Value}}
\newcommand{\Coin}{\type{Coin}}
%% Adding witnesses
\newcommand{\TxIn}{\type{TxIn}}
\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\SKey}{\type{SKey}}
\newcommand{\Hash}{\type{Hash}}
\newcommand{\SkVk}{\type{SkVk}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
%% Adding delegation
\newcommand{\DCert}{\type{DCert}}
\newcommand{\DState}{\type{DState}}
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\VKeyGen}{\type{VKeyGen}}
%% Blockchain
\newcommand{\Gkeys}{\var{G_{keys}}}
\newcommand{\Block}{\type{Block}}
\newcommand{\SlotId}{\type{SlotId}}
\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}
\newcommand{\BDEnv}{\type{BDEnv}}
\newcommand{\BDState}{\type{BDState}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\values}[1]{\fun{values}~ #1}
\newcommand{\balance}[1]{\fun{balance}~ \var{#1}}
%% UTxO witnesses
\newcommand{\inputs}[1]{\fun{inputs}~ \var{#1}}
\newcommand{\wits}[1]{\fun{wits}~ \var{#1}}
\newcommand{\verify}[3]{\fun{verify} ~ #1 ~ #2 ~ #3}
\newcommand{\sign}[2]{\fun{sign} ~ #1 ~ #2}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}
\newcommand{\addr}[1]{\fun{addr}~ \var{#1}}
\newcommand{\hash}[1]{\fun{hash}~ \var{#1}}
\newcommand{\txbody}[1]{\fun{txbody}~ \var{#1}}
% wildcard parameter
\newcommand{\wcard}[0]{\underline{\phantom{a}}}
%% Adding ledgers...
\newcommand{\utxo}[1]{\fun{utxo}~ #1}
%% Delegation
\newcommand{\delegatesName}{\fun{delegates}}
\newcommand{\delegates}[3]{\delegatesName~#1~#2~#3}
\newcommand{\dwho}[1]{\fun{dwho}~\var{#1}}
\newcommand{\depoch}[1]{\fun{depoch}~\var{#1}}
%% Delegation witnesses
\newcommand{\dbody}[1]{\fun{dbody}~\var{#1}}
\newcommand{\dwit}[1]{\fun{dwit}~\var{#1}}
%% Blockchain
\newcommand{\bwit}[1]{\fun{bwit}~\var{#1}}
\newcommand{\bslot}[1]{\fun{bslot}~\var{#1}}
\newcommand{\bbody}[1]{\fun{bbody}~\var{#1}}
\newcommand{\bdlgs}[1]{\fun{bdlgs}~\var{#1}}

\begin{document}

\title{A Simplified Formal Specification of a UTxO Ledger}

\author{}

\date{September 24, 2018}

\maketitle

\begin{abstract}
This documents defines the rules for extending a ledger with transactions. It
is intended to serve as the specification for random generators of transactions
which adhere to the rules presented here.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

This specification models the \textit{conditions} that the different parts of a
transaction have to fulfill so that they can extend a ledger, which is
represented here as a list of transactions. In particular, we model the
following aspects:

\begin{description}
\item[Preservation of value] relationship between the total value of input and
  outputs in a new transaction, and the unspent outputs.
\item[Witnesses] authentication of parts of the transaction data by means of
  cryptographic entities (such as signatures and private keys) contained in
  these transactions.
\item[Delegation] validity of delegation certificates, which delegate the
  block-signing rights from a genesis key to another public key.
\item[Update validation] voting mechanism which captures the identification of
  the voters, and the participants that can post update proposals.
\end{description}

The following aspects will not be modeled (since they are not part of the legacy-free
implementation):
\begin{description}
\item[Stake] staking rights associated to a addresses.
\end{description}

\section{Notation}\label{sec:notation}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequences] Given a set $\type{X}$, $\seqof{\type{X}}$ is the set of
  sequences having elements taken from $\type{X}$. The empty sequence is
  denoted by $\epsilon$, and given a sequence $\Lambda$, $\Lambda; \type{x}$ is
  the sequence that results from appending $\type{x} \in \type{X}$ to
  $\Lambda$.
\item[Functions] $A \to B$ denotes a \textbf{total function} from $A$ to $B$.
  Given a function $f$ we write $f~a$ for the application of $f$ to argument
  $a$. 
\item[Maps and partial functions] $A \mapsto B$ denotes a \textbf{partial
    function} from $A$ to $B$, which can be seen as a map (dictionary) with
  keys in $A$ and values in $B$. Given a map $m \in A \mapsto B$, notation
  $a \mapsto b \in m$ is equivalent to $m~ a = b$.
\end{description}

\section{Cryptographic primitives}
\label{sec:crypto-primitives}

Figure~\ref{fig:crypto-defs} introduces the cryptographic abstractions used in
this document.

\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{vk} & \SKey & \text{signing key}\\            
      \var{vk} & \VKey & \text{verifying key}\\
      \var{hk} & \Hash & \text{hash of a key}\\      
      \sigma & \Sig  & \text{signature}\\
      \var{d} & \Data  & \text{data}\\
    \end{array}
  \end{equation*}
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      (sk, vk) & \SkVk & \text{signing-verifying key pairs}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \hash{} & \VKey \to \Hash
      & \text{hash function} \\
      %
      \fun{verify} & \VKey \times \Data \times \Sig
      & \text{verification relation}\\
    \end{array}
  \end{equation*}
  \emph{Constraints}
  \begin{align*}
    & \forall (sk, vk) \in \SkVk,~ m \in \Data,~ \sigma \in \Sig \cdot
      \verify{vk}{m}{\sigma} \iff \sign{sk}{m} = \sigma
  \end{align*}
  \emph{Notation for serialized and verified data}
  \begin{align*}
    & \serialised{x} & \text{serialised representation of } x\\
    & \mathcal{V}_{\var{vk}}{\serialised{m}}_{\sigma} = \verify{vk}{m}{\sigma}
      & \text{shorthand notation for } \fun{verify}
  \end{align*}
  \caption{Cryptographic definitions}
  \label{fig:crypto-defs}
\end{figure}

\section{Serialization}
\label{sec:serialization}

\begin{todo}
  Discuss here serialization and
  \href{https://iohk.myjetbrains.com/youtrack/issue/CDEC-628}{composable
    serialization}
\end{todo}

\section{UTxO}
\label{sec:state-trans-utxo-1}

The transition rules for unspent outputs are presented in
Figure~\ref{fig:state-trans-utxo}. The states of the UTxO transition system,
along with their types are defined in Figure~\ref{fig:state-trans-utxo-defs}.
Functions on these types are defined in Figure~\ref{fig:utxo-auxiliary-ops}.

\begin{figure*}
  \emph{Primitive types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{txid} & \TxId & \text{transaction id}\\
      %
      ix & \Ix & \text{index}\\
      %
      \var{addr} & \Addr & \text{address}\\
      %
      c & \Coin & \text{currency value}
    \end{array}
  \end{equation*}
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
      \var{txin}
      & \TxIn
      & (\var{txid}, \var{ix})
      & \TxId \times \Ix
      & \text{transaction input}
      \\
      \var{txout}
      & \type{TxOut}
      & (\var{addr}, c)
      & \Addr \times \Coin
      & \text{transaction output}
      \\
      \var{utxo}
      & \UTxO
      & \var{txin} \mapsto \var{txout}
      & \TxIn \mapsto \TxOut
      & \text{unspent tx outputs}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{tx} & \Tx & \text{transaction}\\
    \end{array}
  \end{equation*}
  %
  \emph{Abstract Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \txid{} & \Tx \to \TxId & \text{compute transaction id}\\
      %
      \fun{txbody} & \Tx \to \powerset{\TxIn} \times (\Ix \mapsto \TxOut)
                                  & \text{transaction body}
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:state-trans-utxo-defs}
\end{figure*}

\begin{figure}
  \begin{align*}
    & \fun{txins} \in \Tx \to \powerset{\TxIn}
    & \text{transaction inputs} \\
    & \txins{tx} = \var{inputs} \where \txbody{tx} = (\var{inputs}, ~\wcard)
    \nextdef
    & \fun{txouts} \in \Tx \to \UTxO
    & \text{transaction outputs as UTxO} \\
    & \fun{txouts} ~ \var{tx} =
      \left\{ (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
      \middle| \begin{array}{l@{~}c@{~}l}
                 (\_, \var{outputs}) & = & \txbody{tx} \\
                 \var{ix} \mapsto \var{txout} & \in & \var{outputs}
               \end{array}
      \right\}
    \nextdef
    & \fun{balance} \in \UTxO \to \Coin
    & \text{UTxO balance} \\
    & \fun{balance} ~ utxo = \sum_{(~\wcard ~ \mapsto (\wcard, ~c)) \in \var{utxo}} c
  \end{align*}

  \begin{align*}
    \var{ins} \restrictdom \var{utxo}
    & = \{ i \mapsto o \mid i \mapsto o \in \var{utxo}, ~ i \in \var{ins} \}
    & \text{domain restriction}
    \\
    \var{ins} \subtractdom \var{utxo}
    & = \{ i \mapsto o \mid i \mapsto o \in \var{utxo}, ~ i \notin \var{ins} \}
    & \text{domain exclusion}
    \\
    \var{utxo} \restrictrange \var{outs}
    & = \{ i \mapsto o \mid i \mapsto o \in \var{utxo}, ~ o \in \var{outs} \}
    & \text{range restriction}
  \end{align*}
  \caption{Functions used in UTxO rules}
  \label{fig:utxo-auxiliary-ops}
\end{figure}

\begin{figure}
  \emph{UTxO transitions}
  \begin{equation*}
    \var{\_} \trans{utxo}{\_} \var{\_}
    \subseteq \powerset (\UTxO \times \Tx \times \UTxO)
  \end{equation*}
  \caption{UTxO transition-system types}
  \label{fig:utxo-ts-types}
\end{figure}

\begin{figure}
  \begin{equation}\label{eq:utxo-inductive}
    \inference[UTxO-inductive]
    { \txins{tx} \subseteq \var{utxo}
      & \balance{(\txouts{tx})} \leq \balance{(\txins{tx} \restrictdom \var{utxo})}
    }
    {\var{utxo} \trans{utxo}{tx}
      (\txins{tx} \subtractdom \var{utxo}) \cup \txouts{tx}
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:state-trans-utxo}
\end{figure}

Rule~\ref{eq:utxo-inductive} specifies under which conditions a transaction can
be applied to a set of unspent outputs, and how the set of unspent output
changes with a transaction:
\begin{itemize}
\item Each input spent in the transaction must be in the set of unspent
  outputs.  
\item The balance of the unspent outputs in a transaction (i.e. the total
  amount paid in a transaction) must be equal or less than the amount of spent
  inputs.
\item If the above conditions hold, then the new state will not have the inputs
  spent in transaction $\var{tx}$ and it will have the new outputs in
  $\var{tx}$.
\end{itemize}

\subsection{Properties}
\label{sec:utxo-properties}

\begin{todo}
  Can we prove properties of the transition system of this section? For
  instance we might like to formalize ``double spending'' and prove that these
  rules prevent it. Do we want it?
\end{todo}

\subsection{Witnesses}
\label{sec:witnesses}

The rules for witnesses are presented in Figure~\ref{fig:rules-utxo-witnesses}.
The definitions used in Rule~\ref{eq:utxo-witness-inductive} are given in
Figure~\ref{fig:state-trans-utxo-witnesses-defs}. Note that
Rule~\ref{eq:utxo-witness-inductive} uses the transition relation defined in
Figure~\ref{fig:state-trans-utxo}. The main reason for doing this is to define
the rules incrementally, modeling different aspects in isolation to keep the
rules as simple as possible. Also note that the $\trans{utxo}{}$ relation could
have been defined in terms of $\trans{utxow}{}$ (thus composing the rules in a
different order). The choice here is arbitrary.

\begin{figure}
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{wits} & \Tx \to \powerset{(\VKey \times \Sig)}
      & \text{witnesses of a transaction}\\
      \fun{hash_{spend}} & \Addr \mapsto \Hash
      & \text{hash of a spending key in an address}\\      
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system with witnesses}
  \label{fig:state-trans-utxo-witnesses-defs}
\end{figure}

\begin{figure}
  \begin{align*}
    & \addr{}{} \in \UTxO \to \TxIn \mapsto \Addr & \text{address of an input}\\
    & \addr{utxo} = \{ i \mapsto a \mid i \mapsto (a, \wcard) \in \var{utxo} \} \\
    \nextdef
    & \fun{addr_h} \in \UTxO \to \TxIn \mapsto \Hash & \text{hash of an input address}\\
    & \fun{addr_h}~utxo = \{ i \mapsto h \mid i \mapsto (a, \wcard) \in \var{utxo}
      \wedge a \mapsto h \in \fun{hash_{spend}} \}
  \end{align*}
  \caption{Functions used in rules witnesses}
  \label{fig:witnesses-ops}
\end{figure}

\begin{figure}
  \emph{UTxO with witness transitions}
  \begin{equation*}
    \var{\_} \trans{utxow}{\_} \var{\_}
    \subseteq \powerset (\UTxO \times \Tx \times \UTxO)
  \end{equation*}
  \caption{UTxO with witness transition-system types}
  \label{fig:utxo-witnesses-ts-types}
\end{figure}

\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive}
    \inference[UTxO-wit]
    { \var{utxo} \trans{utxo}{tx} \var{utxo'}\\ ~ \\
      & \forall i \in \txins{tx} \cdot \exists (\var{vk}, \sigma) \in \wits{\var{tx}}
      \cdot 
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma}
      \wedge  \fun{addr_h}~{utxo}~i = \hash{vk}\\
    }
    {\var{utxo} \trans{utxow}{tx} \var{utxo'}}
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules-utxo-witnesses}
\end{figure}

\section{Delegation}
\label{sec:delegation}

An agent owning a key that can sign new blocks can delegate its signing rights
to another key by means of \textit{delegation certificates}. These certificates
are included in the ledger, and therefore also included in the body of the
blocks in the blockchain.

In the blockchain protocol only a certain number of keys can sign blocks, and
the verifying part of these keys\footnote{Also known as public keys.} are
maintained in the genesis block. One important restriction on delegation is
that only the keys in the genesis block can delegate to other keys. However, at
the ledger level we do not know which are these keys, and thus this is a
restriction to be enforced at the blockchain level. In this formalization we
only care about establishing, whether $\var{vk}_s$ delegated its rights to
$\var{vk}_d$. To keep track of this, we use a map from keys to keys.

The rule for delegation is presented in
Figure~\ref{fig:state-trans-delegation}. It states that if $\var{c}$ is a valid
delegation certificate from key $\var{vk}_s$ to key $\var{vk}_d$, then the
delegation map $d$ is updated to contain the key mapping
$\var{vk}_s \mapsto \var{vk}_d$. The symbol $\unionoverride$ denotes
union-override, and is defined in Figure~\ref{fig:delegation-defs}. Another
condition that is checked in the delegation rule is that each genesis key can
issue at most one delegation certificate per epoch. To check this, the states
of the transitions system maintain a map from epochs to set of keys that were
delegated on a given epoch. Finally, the delegation epoch cannot be older than
the current epoch. This is what allow us to clean up the maps of keys delegated
per epoch. Variables to the left of the $\vdash$ (turnstile) symbol are the
\textit{environment} of a rule, which remains constant. This environment (the
current epoch in this case) would be set by the (chain) rules that use
Rule~\ref{eq:delegation}.

\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      c & \DCert & \text{delegation certificate}\\
      vk_g & \VKeyGen & \text{genesis verification key}\\
      e & \Epoch & \text{epoch}\\
    \end{array}
  \end{equation*}
  \emph{Constraints}
  \begin{align*}
    \VKeyGen \subseteq \VKey
  \end{align*}
  \emph{Abstract functions}
  \begin{align*}
    & \fun{dwho} \in \DCert \mapsto (\VKeyGen \times \VKey) & \text{who delegates to who in the certificate}\\
    & \fun{depoch} \in \DCert \mapsto \Epoch & \text{certificate epoch}
  \end{align*}
  \caption{Delegation definitions}
  \label{fig:delegation-defs}
\end{figure}

\begin{figure}
  \begin{align*}
    & \unionoverride \in (A \mapsto B) \to (A \mapsto B) \to (A \mapsto B)
    & \text{union override}\\
    & d_0 \unionoverride d_1 = d_1 \cup (\dom d_1 \subtractdom d_0)
  \end{align*}
  \caption{Functions used in delegation rules}
  \label{fig:delegation-funcs}
\end{figure}

\begin{figure}
  \emph{Delegation states}
  \begin{align*}
    & \DState
      = \left(
        \begin{array}{r@{~\in~}lr}
          \var{dmap} & \VKeyGen \mapsto \VKey & \text{delegation map}\\
          \var{ekeys} & \Epoch \mapsto \powerset{\VKeyGen} & \text{keys delegated per epoch}
        \end{array}\right)
  \end{align*}
  \emph{Delegation transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{deleg}{\_} \_ \in
      \powerset (\Epoch \times \DState \times \DCert \times \DState)
    \end{equation*}
  \caption{Delegation transition-system types}
  \label{fig:delegation-ts-types}
\end{figure}

\begin{figure}
  \begin{equation}\label{eq:delegation}
    \inference[Delegation]
    {\dwho{c} = (vk_s, vk_d) & \depoch{c} = e_c & \var{vk_s} \notin \var{ekeys}~e_c & \var{cepoch} \leq e_c\\
      \var{ekeys'} = \{ (e, \var{vks})  \mid (e, \var{vks}) \in \var{ekeys},~  \var{cepoch} \leq e \}
    }
    {
      \var{cepoch} \vdash
      \left(
      \begin{array}{r}
        \var{dmap}\\
        \var{ekeys}
      \end{array}
      \right)
      \trans{deleg}{c}
      \left(
      \begin{array}{lcl}
        \var{dmap} & \unionoverride & \{\var{vk_s} \mapsto \var{vk_d}\}\\
        \var{ekeys'} & \unionoverride & \{e_c \mapsto (\var{ekeys'}~e_c \cup \{\var{vk_s}\})\}
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Delegation inference rules}
  \label{fig:state-trans-delegation}
\end{figure}

\subsection{Witnesses}
\label{sec:delegation-witnesses}

The rule for certificate witnesses is given in
Figure~\ref{fig:deleg-witnesses}. The new definitions introduced in this rule
are given in Figure~\ref{fig:delegation-witnesses-defs}.

\begin{figure}
  \emph{Primitive types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{epoch} & \Epoch & \text{epoch}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{dbody} & \DCert \mapsto \VKey \times \Epoch
      & \text{body of the delegation certificate}\\
      \fun{dwit} & \DCert \mapsto (\VKeyGen \times \Sig)
      & \text{witness for the delegation certificate}
    \end{array}
  \end{equation*}
  \caption{Delegation witnesses definitions}
  \label{fig:delegation-witnesses-defs}
\end{figure}

\begin{figure}
  \emph{Delegation with witness rule}
  \begin{equation}
    \label{eq:deleg-witnesses}
    \inference[Deleg-wit]
    { \dwit{c} = (\var{vk_s}, \sigma)
      & \var{cepoch} \vdash
      {\left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)}
      \trans{deleg}{c}
      {\left(
      \begin{array}{l}
          \var{dmap}\\
          \var{ekeys}
      \end{array}
      \right)}
      \\ ~ \\
      \verify{vk_s}{\serialised{\dbody{c}}}{\sigma}
    }
    {\var{cepoch} \vdash
      {\left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)}
      \trans{delegw}{c}
      {\left(
      \begin{array}{l}
          \var{dmap}\\
          \var{ekeys}
      \end{array}
      \right)}}
  \end{equation}
  \caption{Delegation witnesses inference rules}
  \label{fig:deleg-witnesses}
\end{figure}

\section{A proposal for the blockchain layer}
\label{sec:blockchain-layer}

\begin{note}
  This section provides a \textbf{proposal} on how the ledger rules can be used
  to build the blockchain ones. It was mainly developed to help me
  understanding what the blockchain layer requires from the ledger layer, and
  the aspects that need to be modeled in the former. In addition, my
  expectation with this section is that we can discuss which tasks should be
  completed in order to finish a first draft of the blockchain and ledger
  specifications, so that we can move forward with the generators. This section
  was not intended as a replacement of the blockchain spec, which can be found
  in a different document.-- Damian Nadales
\end{note}

\subsection{Chain extension}
\label{sec:chain-extension}

The chain extension rule is given in Figure~\ref{fig:chain-extension-rules},
and the definitions used in this rule are presented in
Figure~\ref{fig:chain-extension-defs}. Rule~\ref{eq:rule:chain-extension}
relies on transitions $\trans{bdeleg}{}$, which specify the delegation
behavior, and $\trans{butxo}{}$ which models the evolution of unspent outputs
after applying the transitions in a block. Rules for delegation and unspent
outputs in the context of a block are given in
Sections~\ref{sec:block-delegation} and \ref{sec:block-utxo} respectively.

\begin{figure}
  \emph{Abstract types}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{b} & \Block & \text{block}\\
      \var{s} & \SlotId & \text{slot id}\\
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    \fun{bwit} & \Block \mapsto \VKey \times \Sig & \text{block witness}\\
    \fun{s_0} & \SlotId  & \text{slot zero (smallest slot id)}\\
    \end{array}
  \end{equation*}
  \caption{Blockchain extension definitions}
  \label{fig:chain-extension-defs}
\end{figure}

\begin{figure}
  \emph{Chain extension environment}
  \begin{equation*}
    \CEEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{\Gkeys} & \powerset{\VKeyGen} & \text{genesis keys}\\
        \var{K} & \mathbb{N} & \text{number of nodes}\\
        \var{t} & \mathbb{Q} & \text{byzantine nodes ratio}\\
        \var{d} & \Epoch & \text{delegation liveness parameter}\\
      \end{array}
    \right)
  \end{equation*}
  \emph{Chain extension states}
  \begin{equation*}
    \CEState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \beta & \seqof{\Block} & \text{blockchain}\\
        \var{utxo} & \UTxO & \text{blockchain unspent outputs}\\
        \var{dmap} & \VKeyGen \mapsto \VKey & \text{blockchain delegation map}\\
        \var{signers} & \seqof{\VKeyGen} & \text{last $K$ blockchain signers}\\
        \var{sid_c} & \SlotId & \text{current slot}\\
        \var{pdlgs} & \SlotId \mapsto \seqof{\DCert} & \text{pending delegations}\\
        \var{ekeys} & \Epoch \mapsto \powerset{\VKeyGen} & \text{keys delegated per epoch}
      \end{array}
    \right)
  \end{equation*}
  \emph{Chain extension transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{chain}{\_} \_ \in
      \powerset (\CEEnv \times \CEState \times \Block \times \CEState)
  \end{equation*}
  \caption{Chain extension transition-system types}
  \label{fig:chain-ts-types}
\end{figure}

\begin{figure}
  \begin{equation}
    \label{eq:rule:chain-base}
    \inference[Chain-base]
    {}
    {\left(
        \begin{array}{l}
          \epsilon\\
          \var{utxo}\\
          \var{\{ (\var{vk}, \var{vk}) \mid \var{vk} \in \Gkeys\}}\\
          \emptyset\\
          \var{s_0}\\
          \emptyset\\
          \emptyset
        \end{array}
      \right)
    }
  \end{equation}

  \begin{equation}
    \label{eq:rule:chain-extension}
    \inference[Chain-ext]
    {\var{dmap}~\var{vk_g} = vk_d & \bwit{b} = (\var{vk_d}, \sigma)
      & \bslot{b} = \var{sid_n} & \var{vk_g} \in \Gkeys\\
      \var{sid_c} < \var{sid_n} & \size{\{vk_g\} \restrictdom signers} \leq K * t &
      \verify{vk_d}{\serialised{\bbody{b}}}{\sigma} \\
      \var{signers'} =
         \{ (\var{sid}, \var{vk})
          \mid  (\var{sid}, \var{vk}) \in \var{signers} \cup \{(\var{sid_n}, vk_g)\}
          , \var{sid_n} - K \leq \var{sid} \}\\
      {\begin{array}{l}
         \var{cepoch}\\
         \var{sid_c}\\
         d
       \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{dmap}\\
            \var{pdlgs}\\
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{bdeleg}{b}
      {
        \left(
          \begin{array}{r}
            \var{dmap'}\\
            \var{pdlgs'}\\
            \var{ekeys'}
          \end{array}
        \right)
      }
      &
      {
        \left(
          \begin{array}{l}
            \var{utxo}\\
          \end{array}
        \right)
      }
      \trans{butxo}{b}
      {
        \left(
          \begin{array}{r}
            \var{utxo'}\\
          \end{array}
        \right)
      }
    }
    {
      {\begin{array}{l}
         \Gkeys\\
         K\\
         t\\
         d
      \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \beta\\
            \var{utxo}\\
            \var{dmap}\\
            \var{signers}\\
            \var{sid_c}\\
            \var{pdlgs}\\
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{chain}{b}
      {
        \left(
          \begin{array}{l}
            \beta; b\\
            \var{utxo}\\
            \var{dmap'}\\
            \var{signers'}\\
            \var{sid_n}\\
            \var{pdlgs'}\\
            \var{ekeys'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Chain extension rules}
  \label{fig:chain-extension-rules}
\end{figure}

\subsection{Block delegation}
\label{sec:block-delegation}

The rule for delegation of certificates in a block is shown in
Figure~\ref{fig:block-delegation-rules}, and the new definitions used in this
rule are presented in Figure~\ref{fig:block-delegation-defs}.
Rule~\ref{eq:rule:block-delegation} relies on an inference rule that models the
state changes after applying a sequence of delegation certificates. Such rule
is shown in Figure~\ref{fig:delegation-sequence-rules}.

\begin{figure}
  \emph{Abstract functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{bdlgs} & \Block \mapsto \seqof{\DCert} & \text{delegation certificates in the block}\\
    \end{array}
  \end{equation*}
  \caption{Block delegation definitions}
  \label{fig:block-delegation-defs}
\end{figure}

\begin{figure}
  \emph{Block delegation environments}
  \begin{equation*}
    \BDEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{cepoch} & \Epoch & \text{current epoch}\\
        \var{sid_c} & \SlotId & \text{current slot id}\\
        \var{d} & \Epoch & \text{delegation liveness parameter}\\
      \end{array}
    \right)
  \end{equation*}
  \emph{Block delegation states}
  \begin{equation*}
    \BDState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{dmap} & \VKeyGen \mapsto \VKey & \text{blockchain delegation map}\\
        \var{pdlgs} & \SlotId \mapsto \seqof{\DCert} & \text{pending delegations}\\
        \var{ekeys} & \Epoch \mapsto \powerset{\VKeyGen} & \text{keys delegated per epoch}
      \end{array}
    \right)
  \end{equation*}
  \emph{Block delegation transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{chain}{\_} \_ \in
      \powerset (\BDEnv \times \BDState \times \Block \times \CEState)
  \end{equation*}
  \caption{Block delegation transition-system types}
  \label{fig:block-delegation-ts-types}
\end{figure}

\begin{figure}
  \begin{equation}
    \label{eq:rule:block-delegation}
    \inference[Block-dlg]
    {
      \var{pdlgs'} = \var{pdlgs} \unionoverride \{(\bslot{b} + d) \mapsto \bdlgs{b} \}\\
      \var{spast} = \{ \var{sid} \mid \var{sid} \in \var \dom ~ \var{pdlgs'}
                                    ,~ \var{sid} \leq \var{sid_c}\}\\
      \Gamma = \fun{concat}~ [ \var{dlgs} \mid (\var{sid}, \var{dlgs}) \in \var{pdlgs}
                                          ,~ \var{sid} \leq \var{sid_c}]\\
      \var{cepoch} \vdash
      {
        \left(
          \begin{array}{l}
            \var{dmap}\\
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{delegs}{\Gamma}
      {
        \left(
          \begin{array}{r}
            \var{dmap'}\\
            \var{ekeys'}
          \end{array}
        \right)
      }
    }
    {
      \begin{array}{l}
        \var{cepoch}\\
        \var{sid_c}\\
        d
      \end{array}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{dmap}\\
            \var{pdlgs}\\
            \var{ekeys}
          \end{array}
        \right)
      }
      \trans{bdeleg}{b}
      {
        \left(
          \begin{array}{r}
            \var{dmap'}\\
            \var{\var{spast} \subtractdom pdlgs'}\\
            \var{ekeys'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Block delegation rules}
  \label{fig:block-delegation-rules}
\end{figure}

\begin{figure}
  \begin{equation}
    \inference[Seq-delg-base]
    {}
    { \var{cepoch} \vdash \left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)
        \trans{delegs}{\epsilon}
      \left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)
    }
    \label{eq:rule:sequence-delegation-base}
  \end{equation}

  \begin{equation}
    \inference[Seq-delg-ind]
    { \var{cepoch} \vdash
      {\left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)}
      \trans{delegs}{\Gamma}
      {\left(
        \begin{array}{r}
          \var{dmap'}\\
          \var{ekeys'}
        \end{array}
      \right)}
    \\ ~ \\
    \var{cepoch} \vdash
    {\left(
        \begin{array}{r}
          \var{dmap'}\\
          \var{ekeys'}
        \end{array}
      \right)}
      \trans{delegw}{c}
      {\left(
        \begin{array}{r}
          \var{dmap''}\\
          \var{ekeys''}
        \end{array}
      \right)}
    }
    { \left(
        \begin{array}{r}
          \var{dmap}\\
          \var{ekeys}
        \end{array}
      \right)
      \trans{delegs}{\Gamma; c}
      \left(
        \begin{array}{r}
          \var{dmap''}\\
          \var{ekeys''}
        \end{array}
      \right)
    }
    \label{eq:rule:sequence-delegation-inductive}
  \end{equation}
  \caption{Delegation sequence rules}
  \label{fig:delegation-sequence-rules}
\end{figure}

\subsection{Block UTxO}
\label{sec:block-utxo}


\begin{todo}
  Block-UTxO rules will have the same structure as the rules presented in
  Section~\ref{sec:block-delegation}.
\end{todo}

\end{document}
