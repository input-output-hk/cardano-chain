\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\{\,#1\mid#2\,\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}    % addresses as verification key hashes
\newcommand{\BHash}{\type{BHash}}  % block hashes
\newcommand{\Addr}{\type{Addr}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\GBlock}{\type{GBlock}}
\newcommand{\RBlock}{\type{RBlock}}
\newcommand{\Block}{\type{Block}}
\newcommand{\HCert}{\type{C}}

\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyGen}{\type{SKey_G}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}

%%
%% Function and relation names
%%
\newcommand{\hashname}{hash}
\newcommand{\signname}{sign}
\newcommand{\signedname}{signed}
\newcommand{\signedseqname}{signedc}
\newcommand{\verifyname}{verify}
\newcommand{\delegatename}{delegate}
\newcommand{\validname}{valid}
\newcommand{\keypairname}{pair}
\newcommand{\predbname}{pred} % block predecessor
\newcommand{\toseqname}{toSeq} % option type to a sequence
\newcommand{\predbseqname}{bs} % block predecessor to a sequence

%% 
%% Functions and relations
%%
\newcommand{\sign}[4]{\fun{\signname}\ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\signed}[2]{\fun{\signedname}\ #1 ~ #2}
\newcommand{\signedwindow}[2]{\fun{\signedseqname}\ #1 ~ #2}
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\hash}[1]{\fun{\hashname}\ #1}
\newcommand{\delegate}[2]{\fun{\delegatename}\ #1 ~ #2}
\newcommand{\valid}[2]{\fun{\validname} ~ #1 ~ #2}
\newcommand{\pair}[2]{\fun{\keypairname} ~ #1 ~ #2}
\newcommand{\predb}[1]{\fun{\predbname} ~ #1}
\newcommand{\toseq}[1]{\fun{\toseqname} ~ #1}
\newcommand{\predbseq}[1]{\fun{\predbseqname} ~ #1}

\begin{document}


\title{Specification of the Blockchain Layer}

\author{Marko Dimjašević}

\date{October 5, 2018}

\maketitle

\begin{abstract}
This documents defines a semantics for operations on a blockchain.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequences] Given a set $\type{X}$, $\seqof{\type{X}}$ is the set of
  sequences having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$. The
  $A$ case corresponds to a case when there is a value of type $A$ and the $1$
  case corresponds to a case when there is no value.
\end{description}

\section{Basic definitions}
\label{sec:basic-definitions}

\section{Auxiliary definitions}
\label{sec:auxil-defin}
TODO: Put this note on serialisation somewhere more appropriate.

If $s(\cdot)$ is a function for serialising data and $d(\cdot)$ a function for
deserialising data, their composition $s \circ d$ is not an identity function:
%
this is hard to enforce and it is considered a bad practice in cryptography
design.

\section{Delegation}
\label{sec:delegation}

The genesis block contains verification keys of $n$ servers.
%
Each of $n$ servers keeps its own corresponding signing key locally and does
not share the signing key with anyone else.
%
Only signing keys with their verification counterparts in the genesis block
have the right to sign blocks.
%
However, by the means of delegation certificates, keys from the genesis block
can delegate signing rights to other keys.
%
Delegation is not transitive, i.e., there is no chaining of delegation:
%
only genesis block keys can delegate.


\section{State transitions for Blockchain}
\label{sec:state-trans-chain}

\subsection{Properties}
\label{sec:chain-properties}

\begin{figure}[h]
  \emph{Primitive types}
  %
  \begin{align*}
    & sl \in \Slot & \text{slot time-stamp}\\
    & \Addr = \Hash,\quad hk \in \Addr & \text{address as a key hash}\\
    & sk \in \SKey & \text{signing key}\\
    & vk \in \VKey & \text{verification key}
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    sk_s & \in \SKeyGen \subseteq \SKey & \text{genesis block's signing key}\\
    vk_s & \in \VKeyGen \subseteq \VKey & \text{genesis block's verification key}\\
    h & \in \BHash & \text{block hash}\\
    c & \in \HCert = \VKeyGen \times \VKey \times \Sig & \text{delegation certificate}\\
    sig & \in \Sig  & \text{signature}\\
    data & \in \Data  & \text{data}\\
    (vk_1, \dotsc, vk_n) & \in \GBlock = \VKeyGen^n & \text{genesis block} \\
    (h, sl, d, \sigma) & \in \RBlock = \BHash \times \Slot \times \Data \times \Sig
      & \text{non-genesis block} \\
    b & \in \Block = \GBlock + \RBlock & \text{block}
  \end{align*}
  %
  \emph{Functions and relations}
  %
  \begin{align*}
    \text{\keypairname} & \in \SKey \times \VKey & \text{key pair relation}\\
    \text{\signname} & \in \SKey \times \BHash \times \Slot \times \Data \mapsto \Sig
      & \text{signature function}\\
    \text{\signedname} & \in \SKey \times \RBlock & \text{signature relation}\\
    \text{\signedseqname} & \in \SKeyGen \times \seqof{\Block} \mapsto \powerset{\RBlock}
      & \text{block count function}\\
    \text{\verifyname} & \in \VKey \times \Data \times \Sig
      & \text{verification relation}\\
    \text{\hashname} & \in \Block \mapsto \BHash
      & \text{block hash function}\\
    \text{\delegatename} & \in \SKeyGen \times \VKey \mapsto \HCert
      & \text{delegation function}\\
    \text{\validname} & \in \RBlock \times \VKey
      & \text{block validity relation}\\
    \text{\predbname} & \in \Block \mapsto \Block^?
      & \text{block predecessor function} \\
    \text{\toseqname} & \in \type{A}^? \mapsto \seqof{\type{A}}
      & \text{option to sequence function} \\
    \text{\predbseqname} & \in \Block \mapsto \seqof{\Block}
      & \text{block to sequence function}
  \end{align*}
  \caption{Definitions associated with the blockchain transition system}
  \label{fig:state-trans-abstract}
\end{figure}

\subsubsection{Block Validity}
\label{sec:block-valid}
% This definition is adopted from legacy-free-plan.md, which is written by
% Duncan Coutts

A non-genesis block $\var{b}$ is valid if:
%
\begin{enumerate}
\item it is signed by a key $\var{sk_d}$ for which a current valid heavyweight delegation
  certificate $c = (vk_s, vk_d, \sigma')$ exists,
\item the corresponding certificate $c$ is signed by a key $sk_s$ from the
  genesis block, and
\item in the rolling window of the last $K$ blocks the number of blocks signed
  by keys that $sk_s$ delegated to is no more than a threshold $K \cdot t$,
  where $t$ is a constant that we will pick in the range
  $1/5 \leq t \leq 1/4$.
\end{enumerate}

Relationship between the $\text{\signname}$ function and the
$\text{\verifyname}$ relation is given by \eqref{eq:sign-verify}:

\begin{equation}
  \label{eq:sign-verify}
  \forall (sk, vk) \in \text{\keypairname}, b = (h, sl, d, \sigma) \in \Block.\
  \verify{vk}{d}{\sigma} \iff \sign{sk}{h}{sl}{d} = \sigma.
\end{equation}

The \signedseqname\ function computes for a given genesis block singing key $sk_s$ and a sequence of blocks $\beta$ a set of blocks that are signed by keys $sk_d$ that $sk_s$ delegates to in $\beta$:

\begin{align}
  \label{eq:signed-window}
  \signedwindow{sk_s}{\beta} = & \Set{b}{b \in \beta \wedge b \in \RBlock \wedge \exists sk_d \exists vk_d. (sk_d, vk_d) \in \SKey \times \VKey \\
  & \wedge \delegate{sk_s}{vk_d} = (vk_s, vk_d, \sigma') \wedge \signed{sk_d}{b}}
\end{align}

A block has a block preceding it if it is not the genesis block:

\begin{equation}
  \label{eq:predb}
  \predb{b} =
  \begin{cases}
    1 & \quad \text{if } b \in \GBlock \\
    b' & \quad \text{if } b = (h, sl, d, \sigma) \in \RBlock \wedge \hash{b'} = h
  \end{cases}
\end{equation}

Next, we define a polymorphic function that takes an option type into a
corresponding sequence, which can be applied to the $\Block$ type as well:

\begin{equation}
  \label{eq:toseq}
  \toseq{a} =
  \begin{cases}
    \epsilon & \quad \text{if } a = 1 \\
    \epsilon; a & \quad \text{otherwise}
  \end{cases}
\end{equation}

The function \predbname\ can be monadically applied $m$ times in a row, which
is written as $\predb^m{b}$.

We define a helper function that composes the \predbname\ and the \toseqname\
functions:

\begin{equation}
  \label{eq:predbseq}
  \predbseq{b} = (\text{\toseqname} \circ \text{\predbname})(b)
\end{equation}

Analogously to the \predbname\ function, we define $\predbseq^m{b}$ as:

\begin{equation}
  \label{eq:predbseqton}
  \predbseq^m{b} = (\text{\toseqname} \circ \text{\predbname}^m)(b)
\end{equation}

Finally, we define the block validity relation as:

\begin{align}
  \label{eq:valid-block}
    \valid{b}{vk_d} \implies &
      \exists sk_s \exists vk_s. (sk_s, vk_s) \in \SKeyGen \times \VKey \wedge \\
      & \exists sk_d. (sk_d, vk_d) \in \SKey \times \VKey \wedge
      \delegate{sk_s}{vk_d} = (vk_s, vk_d, \sigma') \wedge \\
      & \exists h, sl, d, \sigma. (h, sl, d, \sigma) = b \wedge
        \sign{sk_d}{h}{sl}{d} = \sigma \wedge \\
      & | \signedwindow{sk_s}{[\predbseq^K\var{b}; \predbseq^{(K-1)}\var{b}; \cdots; \predbseq^1{b}]} | \leq K \cdot t.
\end{align}

The chain extension rule is:

\begin{equation}
  \label{eq:chain-extension}
  \inference[Chain-extension]
  {
    {\begin{array}{c}
       \beta \\
       b = (h, sl, d, \sigma)
    \end{array}}
    &
    {\begin{array}{c}
       \sign{sk_d}{h}{sl}{d} = \sigma \\
       \valid{b}{vk_d} \\
       \delegate{sk_s}{vk_d} = (vk_s, vk_d, \sigma') \\
       \signedwindow{sk_s}{[\predbseq^K\var{b}; \predbseq^{(K-1)}\var{b}; \cdots; \predbseq^1{b}]} | \leq K \cdot t
    \end{array}}
  }
  {\beta \trans{}{\var{b}} {\beta; b}}
\end{equation}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
