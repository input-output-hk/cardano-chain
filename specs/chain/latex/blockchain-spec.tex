\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\{\,#1\mid#2\,\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}    % addresses as verification key hashes
\newcommand{\BHash}{\type{BHash}}  % block hashes
\newcommand{\Addr}{\type{Addr}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\GBlock}{\type{GBlock}}
\newcommand{\RBlock}{\type{RBlock}}
\newcommand{\Block}{\type{Block}}
\newcommand{\HCert}{\type{C}}

\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyGen}{\type{SKey_G}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}

%%
%% Function and relation names
%%
\newcommand{\hashname}{hash}
\newcommand{\signname}{sign}
\newcommand{\signedname}{signed}
\newcommand{\signedseqname}{signedc}
\newcommand{\verifyname}{verify}
\newcommand{\delegatename}{delegate}
\newcommand{\validname}{valid}
\newcommand{\keypairname}{pair}
\newcommand{\predbname}{pred} % block predecessor
\newcommand{\toseqname}{toSeq} % option type to a sequence
%% 
%% Functions and relations
%%
\newcommand{\sign}[4]{\fun{\signname}\ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\signed}[2]{\fun{\signedname}\ #1 ~ #2}
\newcommand{\signedwindow}[2]{\fun{\signedseqname}\ #1 ~ #2}
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\hash}[1]{\fun{\hashname}\ #1}
\newcommand{\delegate}[1]{\fun{\delegatename}\ #1}
\newcommand{\valid}[3]{\fun{\validname} ~ #1 ~ #2 ~ #3}
\newcommand{\pair}[2]{\fun{\keypairname} ~ #1 ~ #2}
\newcommand{\predb}[1]{\fun{\predbname} ~ #1}
\newcommand{\toseq}[1]{\fun{\toseqname} ~ #1}

\begin{document}


\title{Specification of the Blockchain Layer}

\author{Marko Dimjašević}

\date{October 5, 2018}

\maketitle

\begin{abstract}
This documents defines a semantics for operations on a blockchain.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequences] Given a set $\type{X}$, $\seqof{\type{X}}$ is the set of
  sequences having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$.
\end{description}

\section{Basic definitions}
\label{sec:basic-definitions}

\section{Auxiliary definitions}
\label{sec:auxil-defin}
TODO: Put this note on serialisation somewhere more appropriate.

If $s(\cdot)$ is a function for serialising data and $d(\cdot)$ a function for
deserialising data, their composition $s \circ d$ is not an identity function:
this is hard to enforce and it is considered a bad practice in cryptography
design.

\section{State transitions for Blockchain}
\label{sec:state-trans-chain}

\subsection{Properties}
\label{sec:chain-properties}

\begin{figure}[h]
  \emph{Primitive types}
  %
  \begin{align*}
    & sl \in \Slot & \text{slot time-stamp}\\
    & \Addr = \Hash,\quad hk \in \Addr & \text{address as a key hash}\\
    & sk \in \SKey & \text{signing key}\\
    & vk \in \VKey & \text{verification key}
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    sk_G & \in \SKeyGen \subseteq \SKey & \text{genesis block's signing key}\\
    h & \in \BHash & \text{block hash}\\
    c & \in \HCert & \text{heavyweight delegation certificate}\\
    sig & \in \Sig  & \text{signature}\\
    data & \in \Data  & \text{data}\\
    (vk_1, \dotsc, vk_n) & \in \GBlock = \VKey^n & \text{genesis block} \\
    (h, sl, d, \sigma) & \in \RBlock = \BHash \times \Slot \times \Data \times \Sig
      & \text{non-genesis block} \\
    b & \in \Block = \GBlock + \RBlock & \text{block}
  \end{align*}
  %
  \emph{Functions and relations}
  %
  \begin{align*}
    \text{\keypairname} & \in \SKey \times \VKey & \text{key pair relation}\\
    \text{\signname} & \in \SKey \times \BHash \times \Slot \times \Data \mapsto \Sig
      & \text{signature function}\\
    \text{\signedname} & \in \SKey \times \RBlock & \text{signature relation}\\
    \text{\signedseqname} & \in \SKey \times \seqof{\Block} \mapsto \powerset{\RBlock}
      & \text{block count function}\\
    \text{\verifyname} & \in \VKey \times \Data \times \Sig
      & \text{verification relation}\\
    \text{\hashname} & \in \Block \mapsto \BHash
      & \text{block hash function}\\
    \text{\delegatename} & \in \SKey \mapsto \HCert
      & \text{delegation function}\\
    \text{\validname} & \in \RBlock \times \VKey \times \HCert
      & \text{block validity relation}\\
    \text{\predbname} & \in \Block \mapsto \Block^?
      & \text{block predecessor function} \\
    \text{\toseqname} & \in \type{A}^? \mapsto \seqof{\type{A}}
      & \text{option to sequence function}
  \end{align*}
  \caption{Definitions associated with the blockchain transition system}
  \label{fig:state-trans-abstract}
\end{figure}

\subsubsection{Block Validity}
\label{sec:block-valid}
% This definition is adopted from legacy-free-plan.md, which is written by
% Duncan Coutts

A non-genesis block $\var{b}$ is valid if:
%
\begin{enumerate}
\item it is signed by a key $\var{sk_d}$ for which a current valid heavyweight delegation
  certificate $c = (vk_g, vk_d, \sigma)$ exists,
\item the corresponding certificate $c$ is signed by a key $sk_g$ from the
  genesis block, and
\item in the rolling window of the last $K$ blocks the number of blocks signed
  by keys that $sk_g$ delegated to is no more than a threshold $K \cdot t$,
  where $t$ is a constant that we will pick in the range
  $1/5 \leq t \leq 1/4$.
\end{enumerate}

Relationship between the $\text{\signname}$ function and the
$\text{\verifyname}$ relation is given by \eqref{eq:sign-verify}:

\begin{equation}
  \label{eq:sign-verify}
  \forall (sk, vk) \in \text{\keypairname}, b = (h, sl, d, \sigma) \in \Block.\\
  \verify{vk}{d}{\sigma} \iff \sign{sk}{h}{sl}{d} = \sigma.
\end{equation}

\begin{equation}
  \label{eq:signed-window}
  \signedwindow{sk}{\beta} = \Set{b}{b \in \beta \wedge b \in \RBlock \wedge \signed{sk}{b}}
\end{equation}

\begin{align}
  \label{eq:valid-block}
    \valid{b}{vk}{c} \implies &
      \exists sk. (sk, vk) \in \SKeyGen \times \VKey \wedge
      \delegate{sk} = c \wedge \\
      & \exists h, sl, d, \sigma. (h, sl, d, \sigma) = b \wedge
        \sign{sk}{h}{sl}{d} = \sigma \wedge \\
      & | \signedwindow{sk}{\var{B_{sl-K+1}} \cdots \var{B_{sl}}} | \leq K \cdot t.
\end{align}

A block has a block preceding it if it is not the genesis block:

\begin{equation}
  \label{eq:predb}
  \predb{b} =
  \begin{cases}
    1 & \quad \text{if } b \in \GBlock \\
    b' & \quad \text{if } b = (h, sl, d, \sigma) \in \RBlock \wedge \hash{b'} = h
  \end{cases}
\end{equation}

Next, we define a polymorphic function that takes an option type into a
corresponding sequence, which can also be applied to the $\Block$ type:

\begin{equation}
  \label{eq:toseq}
  \toseq{a} =
  \begin{cases}
    \epsilon & \quad \text{if } a = 1 \\
    \epsilon; a & \quad \text{otherwise}
  \end{cases}
\end{equation}

The function \predbname\ can be monadically applied $n$ times in a row, which
is written as $\predb^n{b}$.

% TODO: Define a function that takes a sequence of option types and returns a
% sequence of basic types containing non-empty values.

\begin{equation}
  \label{eq:chain-extension}
  \inference[Chain-extension]
  {\var{B_0}\var{B_1}\cdots\var{B_{\ell}} & \valid{\var{B_{\ell+1}}}{vk}{c}
  }
  {{\var{B_0}\var{B_1}\cdots\var{B_{\ell}}} \trans{}{\var{B_{\ell+1}}} {\var{B_0}\var{B_1}\cdots\var{B_{\ell}}\var{B_{\ell+1}}}}
\end{equation}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
