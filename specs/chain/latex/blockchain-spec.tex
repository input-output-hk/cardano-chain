\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\{\,#1\mid#2\,\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}    % addresses as verification key hashes
\newcommand{\BHash}{\type{BHash}}  % block hashes
\newcommand{\Addr}{\type{Addr}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\Epoch}{\type{Epoch}}
\newcommand{\GBlock}{\type{GBlock}}
\newcommand{\RBlock}{\type{RBlock}}
\newcommand{\Block}{\type{Block}}
\newcommand{\HCert}{\type{C}}

\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyGen}{\type{SKey_G}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}

%%
%% Function and relation names
%%
\newcommand{\hashname}{hash}
\newcommand{\signname}{sign}
\newcommand{\signedname}{signed}
\newcommand{\signedseqname}{signedc}
\newcommand{\verifyname}{verify}
\newcommand{\delegatename}{delegate}
\newcommand{\validname}{valid}
\newcommand{\keypairname}{pair}
\newcommand{\predbname}{pred} % block predecessor
\newcommand{\toseqname}{toSeq} % option type to a sequence
\newcommand{\predbseqname}{bs} % block predecessor to a sequence

%% 
%% Functions and relations
%%
\newcommand{\sign}[4]{\fun{\signname}\ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\signed}[2]{\fun{\signedname}\ #1 ~ #2}
\newcommand{\signedwindow}[2]{\fun{\signedseqname}\ #1 ~ #2}
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\hash}[1]{\fun{\hashname}\ #1}
\newcommand{\delegate}[2]{\fun{\delegatename}\ #1 ~ #2}
\newcommand{\valid}[2]{\fun{\validname} ~ #1 ~ #2}
\newcommand{\pair}[2]{\fun{\keypairname} ~ #1 ~ #2}
\newcommand{\predb}[1]{\fun{\predbname} ~ #1}
\newcommand{\toseq}[1]{\fun{\toseqname} ~ #1}
\newcommand{\predbseq}[1]{\fun{\predbseqname} ~ #1}

\newcommand{\delmap}{\delta}

% Partial and total function aliases
\newcommand{\totalf}{\to}
\newcommand{\partialf}{\mapsto}

% comments
\newcommand{\marko}[1]{\todo[size=\small, color=yellow!40, inline]{Marko: #1}}

\begin{document}


\title{Specification of the Blockchain Layer}

\author{Marko Dimjašević}

\date{October 17, 2018}

\maketitle

\begin{abstract}
This documents defines a semantics for operations on a blockchain.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequence] Given a set $\type{X}$, $\seqof{\type{X}}$ is a sequence
  having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$. The
  $A$ case corresponds to a case when there is a value of type $A$ and the $1$
  case corresponds to a case when there is no value.
\end{description}

\section{Basic definitions}
\label{sec:basic-definitions}

\section{Auxiliary definitions}
\label{sec:auxil-defin}
TODO: Put this note on serialisation somewhere more appropriate.

If $s(\cdot)$ is a function for serialising data and $d(\cdot)$ a function for
deserialising data, their composition $s \circ d$ is not an identity function:
%
this is hard to enforce and it is considered a bad practice in cryptography
design.

\section{Delegation}
\label{sec:delegation}

The genesis block contains verification keys of $n$ servers.
%
As of mid-October 2018, $n = 7$.
%
Each of $n$ servers keeps its own corresponding signing key locally and does
not share the signing key with anyone else.
%
Only signing keys with their verification counterparts in the genesis block
have the right to sign blocks.
%
However, by the means of delegation certificates, keys from the genesis block
can delegate signing rights to other keys.
%
Delegation is not transitive, i.e., there is no chaining of delegation:
%
only genesis block keys can delegate.


\subsection{Delegation Design}
\label{sec:delegation-design}

To keep track of active certificates and when they become valid, a map from
genesis block verification keys to a list of certificates is used.
%
A certificate contains an epoch in which it becomes valid.
%
Each list is sorted by epochs from certificates in the decreasing order (i.e.,
a certificate with an earlier epoch comes latter in the list).
%
The map is initialised by each genesis block key delegating to itself.


If a new certificate is to be posted and added to the map, first it is
checked.
%
The epoch when a certificate becomes valid has to be greater than the epoch of
the head certificate of the corresponding list.
%
The certificate has to have a valid signature.
%
If the certificate is valid, it is prepended to the list of the map key that
is delegating.
%
This also takes care of the property that no key can delegate
twice in an epoch.


Each list in the map is trimmed at the beginning of each epoch by keeping only
the head of the list, i.e., by keeping only one certificate.
%
This head certificate is either a new certificate that becomes valid in this
epoch or it is an old certificate that is still valid and it was not replaced
by any new delegation certificate.
%
Due to trimming, each list in the map has at most two certificates at any
point in time.
%
At the beginning of an epoch, a list has only one element and at any other
point it can have at most two elements (i.e., two certificates) if there was a
new delegation certificate for the next epoch posted.


Because one key's delegation can be changed only for the next epoch, but
not for the current epoch or any epoch after the next, checking whom the key
currently delegates to is a constant-time operation: only the head and
possibly the second item in the list have to be examined.

This approach also supports certificate revocation: it is done by posting a
certificate in which a key delegates to itself.


\section{State transitions for Blockchain}
\label{sec:state-trans-chain}

\subsection{Properties}
\label{sec:chain-properties}

\begin{figure}[h]
  \emph{Primitive types}
  %
  \begin{align*}
    sl & \in \Slot  & \text{slot time-stamp}\\
     e & \in \Epoch & \text{epoch}\\
    sk & \in \SKey  & \text{signing key}\\
    vk & \in \VKey  & \text{verification key}\\
     h & \in \BHash & \text{block hash}\\
   sig & \in \Sig   & \text{signature}\\
  data & \in \Data  & \text{data}
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    sk_s & \in \SKeyGen \subseteq \SKey & \text{genesis block's signing key}\\
    vk_s & \in \VKeyGen \subseteq \VKey & \text{genesis block's verification key}\\
    c & \in \HCert = \VKeyGen \times \VKey \times \Epoch \times \Sig & \text{delegation certificate}\\
    (vk_1, \dotsc, vk_n) & \in \GBlock = \VKeyGen^n & \text{genesis block} \\
    (h, sl, d, \sigma) & \in \RBlock = \BHash \times \Slot \times \Data \times \Sig
      & \text{non-genesis block} \\
    b & \in \Block = \GBlock + \RBlock & \text{block} \\
    \delmap & \in \VKeyGen \totalf \seqof{\HCert}
      & \text{key to certificate list mapping}
  \end{align*}
  %
  \emph{Functions and relations}
  %
  \begin{align*}
    \text{\keypairname} & \in \SKey \times \VKey & \text{key pair relation}\\
    \text{\signname} & \in \SKey \times \BHash \times \Slot \times \Data \partialf \Sig
      & \text{signature function}\\
    \text{\signedname} & \in \SKey \times \RBlock & \text{signature relation}\\
    \text{\signedseqname} & \in \SKeyGen \times \seqof{\Block} \partialf \powerset{\RBlock}
      & \text{block count function}\\
    \text{\verifyname} & \in \VKey \times \Data \times \Sig
      & \text{verification relation}\\
    \text{\hashname} & \in \Block \totalf \BHash
      & \text{block hash function}\\
    \text{\delegatename} & \in \SKeyGen \times \VKey \totalf \HCert
      & \text{delegation function}\\
    \text{\validname} & \in \RBlock \times \VKey
      & \text{block validity relation}\\
    \text{\predbname} & \in \Block \totalf \Block^?
      & \text{block predecessor function} \\
    \text{\toseqname} & \in \type{A}^? \totalf \seqof{\type{A}}
      & \text{option to sequence function} \\
    \text{\predbseqname} & \in \Block \totalf \seqof{\Block}
      & \text{block to sequence function}
  \end{align*}
  \caption{Definitions associated with the blockchain transition system}
  \label{fig:state-trans-abstract}
\end{figure}

\subsubsection{Delegation}
\label{sec:delegation-properties}

In the first epoch, every key from the genesis block delegates to itself, as given by \eqref{eq:init-delpmap}.

\begin{equation}
  \label{eq:init-delpmap}
  \inference[Initial-delegation-map]
  {}
  { \delmap_0 = \Set{(vk_s \partialf c; \epsilon)}{vk_s \in \VKeyGen \wedge c = (vk_s, vk_s, e_0, \sigma)}}
\end{equation}


When an epoch clock ticks and the current epoch with an index $k$ changes to
an epoch with an index $k+1$, each list in the delegation map is shrunk to its
head element, as given by \eqref{eq:next-epoch-delmap}.

\begin{equation}
  \label{eq:next-epoch-delmap}
  \inference[Epoch-change]
  {\delmap_k & \text{epoch clock tick}}
  {\delmap_k \trans{}{} {\delmap_{k+1} = \Set{(vk_s \partialf c; \epsilon)}{(vk_s \partialf c; \Lambda) \in \delmap_k}}}
\end{equation}


If a new valid delegation certificate $c = (vk_s, vk_d, e_j, \sigma)$ that is
a proof that $vk_s$ delegates to $vk_d$ starting in epoch $e_j$ is to be
added, the delegation map is updated at $vk_s$, as given by
\eqref{eq:new-del-cert}.

\begin{equation}
  \label{eq:new-del-cert}
  \inference[New-certificate]
  {
    {
      \begin{array}{c}
        (sk_s, vk_s) \in \SKeyGen \times \VKeyGen \\
        (vk_s \partialf c_h; \lambda) \in \delmap_k \\
        c_h = (vk_s, vk_{d_1}, e_h, \sigma_h)
      \end{array}
    }
    &
    {
      \begin{array}{c}
        c = (vk_s, vk_d, e_j, \sigma) \\
        e_j > e_h
      \end{array}
    }
  }
  {\delmap_k \trans{}{}
    \left(
    {
      \begin{array}{c}
        \delmap_{k'} = \Set{(vk \partialf \Lambda)}{(vk \partialf \Lambda) \in \delmap_k \wedge vk \neq vk_s} \cup \{vk_s \partialf c; c_h; \epsilon\} \\
        \delegate{sk_s}{vk_d} = (vk_s, vk_d, e_j, \sigma)
      \end{array}
    }
    \right)
  }
\end{equation}

\subsubsection{Block Validity}
\label{sec:block-valid}
% This definition is adopted from legacy-free-plan.md, which is written by
% Duncan Coutts

A non-genesis block $\var{b}$ is valid if:
%
\begin{enumerate}
\item it is signed by a key $\var{sk_d}$ for which a current valid heavyweight delegation
  certificate $c = (vk_s, vk_d, e, \sigma')$ exists,
\item the corresponding certificate $c$ is signed by a key $sk_s$ from the
  genesis block, and
\item in the rolling window of the last $K$ blocks the number of blocks signed
  by keys that $sk_s$ delegated to is no more than a threshold $K \cdot t$,
  where $t$ is a constant that we will pick in the range
  $1/5 \leq t \leq 1/4$.
\end{enumerate}


Relationship between the $\text{\signname}$ function and the
$\text{\verifyname}$ relation is given by \eqref{eq:sign-verify}:

\begin{equation}
  \label{eq:sign-verify}
  \forall (sk, vk) \in \text{\keypairname}, b = (h, sl, d, \sigma) \in \Block.\
  \verify{vk}{d}{\sigma} \iff \sign{sk}{h}{sl}{d} = \sigma.
\end{equation}


The \signedseqname\ function computes for a given genesis block singing key $sk_s$ and a sequence of blocks $\beta$ a set of blocks that are signed by keys $sk_d$ that $sk_s$ delegates to in $\beta$:

\begin{align}
  \label{eq:signed-window}
  \signedwindow{sk_s}{\beta} = & \Set{b}{b \in \beta \wedge b \in \RBlock \wedge \exists sk_d \exists vk_d. (sk_d, vk_d) \in \SKey \times \VKey \\
  & \wedge \delegate{sk_s}{vk_d} = (vk_s, vk_d, e, \sigma') \wedge \signed{sk_d}{b}}
\end{align}


A block has a block preceding it if it is not the genesis block:

\begin{equation}
  \label{eq:predb}
  \predb{b} =
  \begin{cases}
    1 & \quad \text{if } b \in \GBlock \\
    b' & \quad \text{if } b = (h, sl, d, \sigma) \in \RBlock \wedge \hash{b'} = h
  \end{cases}
\end{equation}

Next, a polymorphic function that takes an option type into a corresponding
sequence is defined, which can be applied to the $\Block$ type as well:

\begin{equation}
  \label{eq:toseq}
  \toseq{a} =
  \begin{cases}
    \epsilon & \quad \text{if } a = 1 \\
    \epsilon; a & \quad \text{otherwise}
  \end{cases}
\end{equation}

The function \predbname\ can be monadically applied $m$ times in a row, which
is written as $\predb^m{b}$.

A helper function that composes the \predbname\ and the \toseqname\
functions is defined as:

\begin{equation}
  \label{eq:predbseq}
  \predbseq{b} = (\text{\toseqname} \circ \text{\predbname})(b)
\end{equation}

Analogously to the \predbname\ function, $\predbseq^m{b}$ is defined as:

\begin{equation}
  \label{eq:predbseqton}
  \predbseq^m{b} = (\text{\toseqname} \circ \text{\predbname}^m)(b)
\end{equation}

Finally, the block validity relation is defined as:

\begin{align}
  \label{eq:valid-block}
    \valid{b}{vk_d} \implies &
      \exists sk_s \exists vk_s. (sk_s, vk_s) \in \SKeyGen \times \VKey \wedge \\
      & \exists sk_d. (sk_d, vk_d) \in \SKey \times \VKey \wedge
      \delegate{sk_s}{vk_d} = (vk_s, vk_d, e, \sigma') \wedge \\
      & \exists h, sl, d, \sigma. (h, sl, d, \sigma) = b \wedge
        \sign{sk_d}{h}{sl}{d} = \sigma \wedge \\
      & | \signedwindow{sk_s}{[\predbseq^K\var{b}; \predbseq^{(K-1)}\var{b}; \cdots; \predbseq^1{b}]} | \leq K \cdot t.
\end{align}

The chain extension rule is:

\begin{equation}
  \label{eq:chain-extension}
  \inference[Chain-extension]
  {
    {\begin{array}{c}
       \beta \\
       b = (h, sl, d, \sigma)
    \end{array}}
    &
    {\begin{array}{c}
       \sign{sk_d}{h}{sl}{d} = \sigma \\
       \valid{b}{vk_d} \\
       \delegate{sk_s}{vk_d} = (vk_s, vk_d, e, \sigma') \\
       \signedwindow{sk_s}{[\predbseq^K\var{b}; \predbseq^{(K-1)}\var{b}; \cdots; \predbseq^1{b}]} | \leq K \cdot t
    \end{array}}
  }
  {\beta \trans{}{\var{b}} {\beta; b}}
\end{equation}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
