{-# LANGUAGE DeriveAnyClass     #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE OverloadedStrings  #-}

module Cardano.Chain.Ssc.Commitment
       ( Commitment (..)
       , CommitmentSignature
       , SignedCommitment
       , getCommShares

       , dropCommitment
       , dropSignedCommitment
       ) where

import           Cardano.Prelude

import           Control.Lens (each, traverseOf)
import qualified Data.Map.Strict as Map

import           Cardano.Binary.Class (AsBinary, Bi (..), DecoderError (..),
                     Dropper, dropBytes, dropList, dropMap, dropTriple,
                     encodeListLen, enforceSize, fromBinary, serialize')
import           Cardano.Chain.Slotting (EpochIndex)
import           Cardano.Crypto (EncShare, PublicKey, SecretProof, Signature,
                     VssPublicKey, dropSecretProof)


-- | Commitment is a message generated during the first stage of SSC.
--   It contains encrypted shares and proof of secret.
--
--   There can be more than one share generated for a single participant.
data Commitment = Commitment
    { commProof  :: !SecretProof
    , commShares :: !(Map (AsBinary VssPublicKey) (NonEmpty (AsBinary EncShare)))
    } deriving (Show, Eq, Generic)
      deriving anyclass NFData

instance Ord Commitment where
    compare = comparing (serialize' . commProof) <>
              comparing (sort . Map.toList . commShares)

dropCommitment :: Dropper s
dropCommitment = do
  enforceSize "Commitment" 2
  -- Map (AsBinary VssPublicKey) (NonEmpty (AsBinary EncShare))
  dropMap dropBytes (dropList dropBytes)
  dropSecretProof

instance Bi Commitment where
  encode comm =
    encodeListLen 2 <> encode (commShares comm) <> encode (commProof comm)

  decode = do
    enforceSize "Commitment" 2
    shares <- decode
    when (null shares) $ cborError $ DecoderErrorCustom "Commitment" "No shares"
    proof <- decode
    pure $ Commitment proof shares

-- | Signature which ensures that commitment was generated by node
-- with given public key for given epoch.
type CommitmentSignature = Signature (EpochIndex, Commitment)

type SignedCommitment = (PublicKey, Commitment, CommitmentSignature)

dropSignedCommitment :: Dropper s
dropSignedCommitment = dropTriple dropBytes dropCommitment dropBytes

-- | Get commitment shares.
getCommShares :: Commitment -> Maybe [(VssPublicKey, NonEmpty EncShare)]
getCommShares =
    traverseOf (each . _1) (rightToMaybe . fromBinary) <=<      -- decode keys
    traverseOf (each . _2 . each) (rightToMaybe . fromBinary) . -- decode shares
    Map.toList . commShares
